/*
 * The exercises description is written in English, so I'm delivering the
 * answers in English.
 *
 * The programs will be compiled using libc-2.28 and gcc-8.3.0.
 *
 * All three exercises contain a Makefile to compile the code.
 *
 * I didn't have much diffilculty when solving exercises 1 and 3.
 *
 * Exercise 2, a bit longer, was a bit more difficult. My first aproach was
 * printing the lines as they are read, it had had a catch. If the line is two
 * big it must be broken down, so it is possible to reach the columns limit
 * when reading a line. So, the header and the extra new line may be inserted
 * when printing a page or when printing a line, making the program somewhat
 * more complex.
 *
 * So I tried a second aproach, this time a small memory module was written.
 * A whole page is read from an input file and saved into memory. Then the
 * page reach "nRows" lines it is dump to the screen. Formatting gets more
 * simple this way. That is the delivered solution.
 *
 * Exercise 2:
 * ------------
 *
 * There are two programs in this solution:
 *
 * "checkPager.sh" - Bash script to check the pager.
 * "mPager.c" - The pager.
 *
 * The program is divided in three modules, "memory.c" for memory management,
 * "mPager.c" as the main program and "format.c" to print to the screen.
 *
 * The description points to an "extra feature", we assume it is compulsary.
 *
 * The description doesn't mention any kind of user input. It is only enabled
 * when the input file is NOT stdin.
 *
 * We need to accept an arbitrary number of file names from the command line.
 * So we define and array of pointers to strings, a pointer for every file
 * name. Since we don't know the array length, it must be dynamically
 * allocated.
 *
 * We can keep an integer variable to count the number of files.
 *
 * The above is quite precisely "argc" and "argv" ANSI C definition. So we
 * only need to use them to store and get filenames.
 *
 * We must read every file line by line. We can use C standard libraries for
 * that task. We could use "gets" wich is portable but not so safe. We are
 * using GNU C library "getline" instead. Since the exercise compels us to use
 * gcc, we might reasonable assume that GNU C library will also be available,
 * so "getline" will be allowed for us.
 *
 * The exercise asks to concatenate one text file after the other and
 * show it to the screen in 80 line pages. We assume a length of 80 lines of
 * text, as they are read from the file, without counting the one at the
 * begining showing a page number, or the one at the end to allow user input.
 *
 * Here is a brief description for the "mPager":
 *
 * First we step over every file on the function "pager", sending a stream
 * pointer to "prnPage".
 *
 * In this latter function we step over every line saving it to a queue. If
 * the line length is greater than "nCols" it is broken into smaller blocks
 * with "nCols" length. When the queue gets full (with at least "nRows"
 * lines, it is formatted and printed to the screen. Once all contents is
 * printed the queue is reset.
 *
 * After printing a page, a footer invites the user to continue by hitting
 * "Intro" key, but only if the input file is NOT "sdtin".
 */

/*
 * Improvements:
 *
 * 1.- We are using pointer arithmetics to break the lines in blocks. So we
 *  would use a memory debugger (like valgrind) to make sure we don't get
 * buffer overruns or other memory issues.
 * 2.- We could write some more tests.
 * 3.- The name of the file could be printed.
 * 4.- The number of lines and total bytes for every file could be printed.
 * 5.- The Linux terminal could be set to non-canonical mode to get keyboard
 * user input without having to resort to "gethar ()", or we could use
 * ncurses.
 * 6.- We could allow the user navigate through the listed files with arrow keys
 * and the like.
 *
 * To implement those improvements we could:
 *
 * 1.- Just run the program under valgrind with the makefile.
 * 2.- We must add new text files and run the program against them. Those
 * files may have specific number of lines and line lengths to check the
 * program behaviour. We can use "gcov" to ensure the desired code coverage.
 * 3.- It can easily be printed at "prnHeader" function.
 * 4.- Like above.
 * 5.- Since reading a page and printing it is done on different modules we
 * could modify the formating module accordingly. All ncurses related code
 * could be added to the format module, making the program follow the MVC
 * logic pattern.
 * 6.- Like above.
 */

